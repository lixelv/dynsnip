export const snippets = [
    {
        "label": "AVL Tree",
        "body": [
            "#include <iostream>",
            "",
            "template <typename T>",
            "struct Node {",
            "  T val;",
            "  Node *left = nullptr;",
            "  Node *right = nullptr;",
            "  int height = 1;",
            "",
            "  Node(T v) : val(v) {}",
            "};",
            "",
            "template <typename T>",
            "class AVL {",
            "public:",
            "  using CompareFunction = int (*)(T, T);",
            "",
            "  Node<T> *root;",
            "  CompareFunction compare;",
            "",
            "  AVL(CompareFunction cmp = nullptr) {",
            "    if (cmp == nullptr) {",
            "      cmp = [](T a, T b) {",
            "        if (a < b)",
            "          return -1;",
            "        if (a > b)",
            "          return 1;",
            "        return 0;",
            "      };",
            "    }",
            "    compare = cmp;",
            "    root = nullptr;",
            "  }",
            "",
            "  ~AVL() { clear(root); }",
            "",
            "  void insert(T val) { root = insertNode(root, val); }",
            "  T *search(T val) { return searchNode(root, val); }",
            "  bool remove(T val) {",
            "    bool removed = false;",
            "    root = removeNode(root, val, removed);",
            "    return removed;",
            "  }",
            "",
            "  void clear() {",
            "    clear(root);",
            "    root = nullptr;",
            "  }",
            "",
            "  void print() {",
            "    print(root, 0);",
            "    std::cout << std::endl;",
            "  }",
            "",
            "private:",
            "  int getHeight(Node<T> *node) { return node ? node->height : 0; }",
            "",
            "  int getBalance(Node<T> *node) {",
            "    if (!node)",
            "      return 0;",
            "    return getHeight(node->left) - getHeight(node->right);",
            "  }",
            "",
            "  void updateHeight(Node<T> *node) {",
            "    if (!node)",
            "      return;",
            "    int hl = getHeight(node->left);",
            "    int hr = getHeight(node->right);",
            "    node->height = std::max(hl, hr) + 1;",
            "  }",
            "",
            "  Node<T> *rotateRight(Node<T> *y) {",
            "    Node<T> *x = y->left;",
            "    Node<T> *T2 = x->right;",
            "",
            "    x->right = y;",
            "    y->left = T2;",
            "",
            "    updateHeight(y);",
            "    updateHeight(x);",
            "",
            "    return x;",
            "  }",
            "",
            "  Node<T> *rotateLeft(Node<T> *x) {",
            "    Node<T> *y = x->right;",
            "    Node<T> *T2 = y->left;",
            "",
            "    y->left = x;",
            "    x->right = T2;",
            "",
            "    updateHeight(x);",
            "    updateHeight(y);",
            "",
            "    return y;",
            "  }",
            "",
            "  Node<T> *balanceNode(Node<T> *node) {",
            "    if (!node)",
            "      return node;",
            "",
            "    updateHeight(node);",
            "    int balance = getBalance(node);",
            "",
            "    // LL",
            "    if (balance > 1 && getBalance(node->left) >= 0) {",
            "      return rotateRight(node);",
            "    }",
            "",
            "    // LR",
            "    if (balance > 1 && getBalance(node->left) < 0) {",
            "      node->left = rotateLeft(node->left);",
            "      return rotateRight(node);",
            "    }",
            "",
            "    // RR",
            "    if (balance < -1 && getBalance(node->right) <= 0) {",
            "      return rotateLeft(node);",
            "    }",
            "",
            "    // RL",
            "    if (balance < -1 && getBalance(node->right) > 0) {",
            "      node->right = rotateRight(node->right);",
            "      return rotateLeft(node);",
            "    }",
            "",
            "    return node;",
            "  }",
            "",
            "  Node<T> *insertNode(Node<T> *node, T val) {",
            "    if (!node) {",
            "      return new Node<T>(val);",
            "    }",
            "",
            "    int r = compare(val, node->val);",
            "    if (r < 0) {",
            "      node->left = insertNode(node->left, val);",
            "    } else if (r > 0) {",
            "      node->right = insertNode(node->right, val);",
            "    } else {",
            "      return node;",
            "    }",
            "",
            "    return balanceNode(node);",
            "  }",
            "",
            "  T *searchNode(Node<T> *node, T val) {",
            "    if (!node)",
            "      return nullptr;",
            "",
            "    int r = compare(val, node->val);",
            "    if (r < 0)",
            "      return searchNode(node->left, val);",
            "    if (r > 0)",
            "      return searchNode(node->right, val);",
            "    return &(node->val);",
            "  }",
            "",
            "  Node<T> *findMin(Node<T> *node) {",
            "    while (node && node->left) {",
            "      node = node->left;",
            "    }",
            "    return node;",
            "  }",
            "",
            "  Node<T> *removeNode(Node<T> *node, T val, bool &removed) {",
            "    if (!node) {",
            "      removed = false;",
            "      return nullptr;",
            "    }",
            "",
            "    int r = compare(val, node->val);",
            "    if (r < 0) {",
            "      node->left = removeNode(node->left, val, removed);",
            "    } else if (r > 0) {",
            "      node->right = removeNode(node->right, val, removed);",
            "    } else {",
            "      removed = true;",
            "      if (!node->left && !node->right) {",
            "        delete node;",
            "        return nullptr;",
            "      } else if (!node->left) {",
            "        Node<T> *temp = node->right;",
            "        delete node;",
            "        return temp;",
            "      } else if (!node->right) {",
            "        Node<T> *temp = node->left;",
            "        delete node;",
            "        return temp;",
            "      } else {",
            "        Node<T> *successor = findMin(node->right);",
            "        node->val = successor->val;",
            "        node->right = removeNode(node->right, successor->val, removed);",
            "      }",
            "    }",
            "",
            "    return balanceNode(node);",
            "  }",
            "",
            "  void print(Node<T> *node, int depth) {",
            "    if (node == nullptr) {",
            "      return;",
            "    }",
            "",
            "    print(node->right, depth + 1);",
            "",
            "    for (int i = 0; i < depth; i++) {",
            "      std::cout << \"   \";",
            "    }",
            "    std::cout << node->val << std::endl;",
            "",
            "    print(node->left, depth + 1);",
            "  };",
            "",
            "  void clear(Node<T> *node) {",
            "    if (!node)",
            "      return;",
            "    clear(node->left);",
            "    clear(node->right);",
            "    delete node;",
            "  }",
            "};",
            "",
            "$1"
        ]
    },
    {
        "label": "Binary Search Tree",
        "body": [
            "#include <iostream>",
            "",
            "template <typename T>",
            "struct Node {",
            "  T val;",
            "  Node *left = nullptr;",
            "  Node *right = nullptr;",
            "  Node(T v) : val(v) {}",
            "};",
            "",
            "template <typename T>",
            "class BST {  ",
            "public:",
            "  using CompareFunction = int (*)(T, T);",
            "",
            "  Node<T>* root;",
            "  CompareFunction compare;",
            "  BST(CompareFunction cmp = nullptr) {",
            "    if (cmp == nullptr) {",
            "      cmp = [](T a, T b) { return a - b; };",
            "    }",
            "",
            "    compare = cmp;",
            "    root = nullptr;",
            "  }",
            "",
            "  ~BST() { clear(root); }",
            "",
            "  void insert(T val) { insertNode(root, val); }",
            "  T *search(T val) { return searchNode(root, val); }",
            "  bool remove(T val) { return removeNode(root, val); }",
            "  void clear() {",
            "    clear(root);",
            "    root = nullptr;",
            "  }",
            "",
            "  void print() {",
            "    std::cout << \"Tree structure:\" << std::endl;",
            "    print(root, 0);",
            "    std::cout << std::endl;",
            "  }",
            "",
            "private:",
            "  void insertNode(Node<T>*  &node, T val) {",
            "    if (node == nullptr) {",
            "      node = new Node<T>(val);",
            "      return;",
            "    }",
            "",
            "    int r = compare(val, node->val);",
            "    if (r <= 0) {",
            "      insertNode(node->left, val);",
            "    } else {",
            "      insertNode(node->right, val);",
            "    }",
            "  }",
            "",
            "  T *searchNode(Node<T>*  node, T val) {",
            "    if (node == nullptr) {",
            "      return nullptr;",
            "    }",
            "",
            "    int r = compare(val, node->val);",
            "",
            "    if (r < 0) {",
            "      return searchNode(node->left, val);",
            "    } else if (r > 0) {",
            "      return searchNode(node->right, val);",
            "    } else {",
            "      return &(node->val);",
            "    }",
            "  }",
            "",
            "  bool removeNode(Node<T> *&node, T val) {",
            "    if (node == nullptr) {",
            "      return false;",
            "    }",
            "",
            "    int r = compare(val, node->val);",
            "",
            "    if (r < 0) {",
            "      return removeNode(node->left, val);",
            "    } else if (r > 0) {",
            "      return removeNode(node->right, val);",
            "    } else {",
            "      if (node->left == nullptr && node->right == nullptr) {",
            "        delete node;",
            "        node = nullptr;",
            "      } else if (node->left == nullptr) {",
            "        Node<T> *temp = node;",
            "        node = node->right;",
            "        delete temp;",
            "      } else if (node->right == nullptr) {",
            "        Node<T> *temp = node;",
            "        node = node->left;",
            "        delete temp;",
            "      } else {",
            "        Node<T> *successor = findMin(node->right);",
            "        node->val = successor->val;",
            "        removeNode(node->right, successor->val);",
            "      }",
            "      return true;",
            "    }",
            "  }",
            "",
            "  Node<T> *findMin(Node<T> *node) {",
            "    while (node->left != nullptr) {",
            "      node = node->left;",
            "    }",
            "    return node;",
            "  }",
            "",
            "  void print(Node<T>* node, int depth) {",
            "      if (node == nullptr) {",
            "        return;",
            "      }",
            "",
            "      print(node->right, depth + 1);",
            "",
            "      for (int i = 0; i < depth; i++) {",
            "        std::cout << \"   \";",
            "      }",
            "      std::cout << node->val << std::endl;",
            "",
            "      print(node->left, depth + 1);",
            "  };",
            "",
            "  void clear(Node<T>*  node) {",
            "    if (!node)",
            "      return;",
            "    clear(node->left);",
            "    clear(node->right);",
            "    delete node;",
            "  }",
            "};",
            "",
            "$1"
        ]
    },
    {
        "label": "Heap",
        "body": [
            "#include <iostream>",
            "#include <vector>",
            "",
            "template <typename T, bool (*Comp)(const T &, const T &)>",
            "class Heap {",
            "public:",
            "  Heap() { std::vector<T> arr; }",
            "",
            "  void insert(int val) {",
            "    arr.push_back(val);",
            "    siftUp(arr.size() - 1);",
            "  }",
            "",
            "  int popRoot() {",
            "    if (arr.empty()) {",
            "      throw std::out_of_range(\"Heap is empty\");",
            "    }",
            "",
            "    int result = arr[0];",
            "    int last = arr.size() - 1;",
            "",
            "    std::swap(arr[0], arr[last]);",
            "    arr.pop_back();",
            "",
            "    if (!arr.empty()) {",
            "      siftDown(0);",
            "    }",
            "",
            "    return result;",
            "  }",
            "",
            "  int peek() const {",
            "    if (arr.empty()) {",
            "      throw std::out_of_range(\"Heap is empty\");",
            "    }",
            "    return arr[0];",
            "  }",
            "",
            "  bool empty() const { return arr.empty(); }",
            "",
            "  int size() const { return static_cast<int>(arr.size()); }",
            "",
            "  void clear() { arr.clear(); }",
            "",
            "  void print() const {",
            "    print(0, 0);",
            "    std::cout << std::endl;",
            "  }",
            "",
            "private:",
            "  std::vector<int> arr;",
            "",
            "  void siftUp(int i) {",
            "    while (i > 0) {",
            "      int p = (i - 1) / 2;",
            "      if (Comp(arr[i], arr[p])) {",
            "        std::swap(arr[i], arr[p]);",
            "        i = p;",
            "      } else {",
            "        break;",
            "      }",
            "    }",
            "  }",
            "",
            "  void siftDown(int i) {",
            "    int n = static_cast<int>(arr.size());",
            "    while (true) {",
            "      int left = 2 * i + 1;",
            "      int right = 2 * i + 2;",
            "      int nest = i;",
            "",
            "      if (left < n && Comp(arr[left], arr[nest])) {",
            "        nest = left;",
            "      }",
            "      if (right < n && Comp(arr[right], arr[nest])) {",
            "        nest = right;",
            "      }",
            "",
            "      if (nest != i) {",
            "        std::swap(arr[i], arr[nest]);",
            "        i = nest;",
            "      } else {",
            "        break;",
            "      }",
            "    }",
            "  }",
            "",
            "  void print(int index, int depth) const {",
            "    if (index >= static_cast<int>(arr.size()))",
            "      return;",
            "",
            "    int right = 2 * index + 2;",
            "    int left = 2 * index + 1;",
            "",
            "    print(right, depth + 1);",
            "",
            "    for (int i = 0; i < depth; ++i) {",
            "      std::cout << \"   \";",
            "    }",
            "",
            "    std::cout << arr[index] << std::endl;",
            "    print(left, depth + 1);",
            "  }",
            "};",
            "",
            "template <typename T> bool minCompare(const T &a, const T &b) { return a < b; }",
            "template <typename T> bool maxCompare(const T &a, const T &b) { return a > b; }",
            "",
            "template <typename T = int> using MinHeap = Heap<T, minCompare<T>>;",
            "template <typename T = int> using MaxHeap = Heap<T, maxCompare<T>>;",
            "",
            "$1"
        ]
    },
    {
        "label": "Deque",
        "body": [
            "#include <iostream>",
            "",
            "template <typename T> struct Node {",
            "  T data;",
            "  Node<T> *next;",
            "  Node<T> *prev;",
            "",
            "  Node(T v) {",
            "    data = v;",
            "    next = nullptr;",
            "    prev = nullptr;",
            "  }",
            "};",
            "",
            "template <typename T>",
            "class Deque {",
            "public:",
            "  Node<T> *head;",
            "  Node<T> *tail;",
            "  int size;",
            "  Deque() {",
            "    head = nullptr;",
            "    tail = nullptr;",
            "    size = 0;",
            "  }",
            "",
            "  ~Deque() {",
            "    Node<T> *current = this->head;",
            "    while (current != nullptr) {",
            "      Node<T> *next = current->next;",
            "      delete current;",
            "      current = next;",
            "    }",
            "  }",
            "",
            "  T popBack() {",
            "    if (tail == nullptr) {",
            "      throw std::runtime_error(\"Deque is empty\");",
            "    }",
            "",
            "    Node<T> *nodeToDelete = tail;",
            "    T data = tail->data;",
            "",
            "    if (head == tail) {",
            "      head = nullptr;",
            "      tail = nullptr;",
            "    } else {",
            "      tail = tail->prev;",
            "      tail->next = nullptr;",
            "    }",
            "",
            "    delete nodeToDelete;",
            "    size--;",
            "    return data;",
            "  }",
            "",
            "  T popForward() {",
            "    if (head == nullptr) {",
            "      throw std::runtime_error(\"Deque is empty\");",
            "    }",
            "",
            "    Node<T> *nodeToDelete = head;",
            "    T data = head->data;",
            "",
            "    if (head == tail) {",
            "      head = nullptr;",
            "      tail = nullptr;",
            "    } else {",
            "      head = head->next;",
            "      head->prev = nullptr;",
            "    }",
            "",
            "    delete nodeToDelete;",
            "    size--;",
            "    return data;",
            "  }",
            "",
            "  void pushBack(T data) {",
            "    Node<T> *node = new Node<T>(data);",
            "",
            "    if (tail == nullptr) {",
            "      head = node;",
            "      tail = node;",
            "    } else {",
            "      tail->next = node;",
            "      node->prev = tail;",
            "      tail = node;",
            "    }",
            "    size++;",
            "  }",
            "",
            "  void pushForward(T data) {",
            "    Node<T> *node = new Node<T>(data);",
            "",
            "    if (head == nullptr) {",
            "      head = node;",
            "      tail = node;",
            "    } else {",
            "      head->prev = node;",
            "      node->next = head;",
            "      head = node;",
            "    }",
            "    size++;",
            "  }",
            "",
            "  void print() {",
            "    Node<T> *current = head;",
            "    std::cout << \"Deque (size=\" << size << \"): \";",
            "    while (current != nullptr) {",
            "      std::cout << current->data << \" \";",
            "      current = current->next;",
            "    }",
            "    std::cout << std::endl;",
            "  }",
            "};",
            "",
            "$1"
        ]
    },
    {
        "label": "Queue",
        "body": [
            "#include <iostream>",
            "",
            "template <typename T>",
            "struct Node {",
            "  T data;",
            "  Node<T> *next;",
            "",
            "  Node(T data, Node<T> *next = nullptr) : data(data), next(next) {}",
            "};",
            "",
            "template <typename T>",
            "class Queue {",
            "public:",
            "  Queue() {",
            "    head = nullptr;",
            "    tail = nullptr;",
            "    size = 0;",
            "  }",
            "",
            "  ~Queue() {",
            "    Node<T> *current = this->head;",
            "    while (current != nullptr) {",
            "      Node<T> *next = current->next;",
            "      delete current;",
            "      current = next;",
            "    }",
            "  }",
            "",
            "  void enqueue(T data) {",
            "    size++;",
            "    Node<T> *node = new Node<T>(data);",
            "    if (tail == nullptr) {",
            "      head = tail = node;",
            "    } else {",
            "      tail->next = node;",
            "      tail = node;",
            "    }",
            "  }",
            "",
            "  T dequeue() {",
            "    if (size == 0) {",
            "      throw std::out_of_range(\"Queue is empty\");",
            "    }",
            "",
            "    size--;",
            "    T data = head->data;",
            "    Node<T> *oldHead = head;",
            "    head = head->next;",
            "    delete oldHead;",
            "",
            "    if (head == nullptr) {",
            "      tail = nullptr;",
            "    }",
            "",
            "    return data;",
            "  }",
            "",
            "  bool isEmpty() { return size == 0; }",
            "",
            "  int getSize() { return size; }",
            "",
            "  void print() {",
            "    Node<T> *current = head;",
            "    std::cout << \"Queue (size=\" << size << \"): \";",
            "    while (current != nullptr) {",
            "      std::cout << current->data << \" \";",
            "      current = current->next;",
            "    }",
            "    std::cout << std::endl;",
            "  }",
            "",
            "private:",
            "  Node<T> *head;",
            "  Node<T> *tail;",
            "  int size;",
            "};",
            "",
            "$1"
        ]
    },
    {
        "label": "Stack",
        "body": [
            "#include <iostream>",
            "",
            "template <typename T>",
            "struct Node {",
            "  T data;",
            "  Node<T> *next;",
            "};",
            "",
            "template <typename T>",
            "class Stack {",
            "public:",
            "  Stack() {",
            "    head = nullptr;",
            "    size = 0;",
            "  }",
            "",
            "  ~Stack() {",
            "    Node<T> *current = head;",
            "    while (current != nullptr) {",
            "      Node<T> *next = current->next;",
            "      delete current;",
            "      current = next;",
            "    }",
            "  }",
            "",
            "  T pop() {",
            "    if (isEmpty()) {",
            "      throw std::runtime_error(\"Stack is empty\");",
            "    }",
            "",
            "    size--;",
            "    T data = head->data;",
            "    head = head->next;",
            "    delete head;",
            "    return data;",
            "  }",
            "",
            "  void push(T data) {",
            "    size++;",
            "    Node<T> *node = new Node<T>(data);",
            "    node->next = head;",
            "    head = node;",
            "  }",
            "",
            "  bool isEmpty() { return size == 0; }",
            "",
            "  int getSize() { return size; }",
            "",
            "  void print() {",
            "    Node<T> *current = head;",
            "    std::cout << \"Stack (size=\" << size << \"): \";",
            "    while (current != nullptr) {",
            "      std::cout << current->data << \" \";",
            "      current = current->next;",
            "    }",
            "    std::cout << std::endl;",
            "  }",
            "",
            "private:",
            "  Node<T> *head;",
            "  int size;",
            "};",
            "",
            "$1"
        ]
    }
];